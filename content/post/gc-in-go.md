+++
date = "2015-10-16"
title = "Новый сборщик мусора в Go 1.5"
description = "Попробуем понять, что нового в сборщике мусора для Go 1.5 и чем он отличается от предыдущей версии"
keywords = ["go", "golang", "gc", "gargage collector", "сборка мусора", "go 1.5"]
categories = ["go", "сборщик мусора"]
draft = true
+++

Этой статьёй о сборщике мусора я хотел бы начать цикл о специфики и реализации рантайма в Go.

Не смотря на то, что каждая версия го улучшала производительность сборщика, но именно С выходом, версии 1.5, с его сборщиком мусора произошли существенные изменения. На выступлении чувака, мы видим существенные/удивительные цифры. Давайте  попробуем разобраться, что на самом деле было сделано и как это повлияет на работу программ, написанных на го. 


### Зачем нужны сборщики мусора?
Прежде чем начать, я хотел бы ввести вас кратко в то, какие бывают техники сборки мусора, а так же определить основные термины, используемые в статье. 

Управлять памятью можно несколькими способами, например вручную, как сделано в языках, вроде си, c++, objective-c(уточнить версии). Вы сами выделяете нужную память и потом сами же очищаете её. Не смотря на то, что это достаточно быстро, а паузы при выделении памяти достаточно предсказуемы, существует ряд проблем. Например разработчик может забыть очистить память, или наоборот, очистить слишком рано. И чем больше людей участвуют в разработке - тем выше вероятность утечек и ошибок. (Добавить другие проблемы и плюсы)

Поэтому появились техники, которые снимают с разработчика ответственность за управление памятью.
Одна из таких техник, это подсчет ссылок. Например обжектив с, с его arc. Питон, с++ и шаред поинтеры. Смысл в том, что каждый обьект хранит счетчик, который показывает, сколько других объектов ссылается на него. В тот момент, когда счетчик обнуляется, этот обьект можно освободить. Не смотря на то, он имеет множество плюсов, но у него так же есть и недостатки. (Добавить плюсы и недостатки)

Другая техника, это использование сборщика мусора. Джава, дотнет, го, итд. Смысл в том, что рядом с программой есть рантайм, который переодически сканирует все обьекты в памяти, находит те, что больше не используются и освобождает их. Основные плюсы и минусы данного метода. Больше про гс можно узнать в замечательной книге .

### Эволюция сборщиков мусора в Go

Изначально хараектеристики сборщика были такими:

 * mark-and-sweep (parallel implementation)
 * без поколений
 * без компактизации
 * консервативный (conservative) - пояснить что это значит?
 * с остановкой мира
 * bitmap-based representation
 * zero-cost when the program is not allocating memory (that is: shuffling pointers around is as fast as in C, although in practice this runs somewhat slower than C because the Go compiler is not as advanced as C compilers such as GCC)
 * с поддержкой финалайзеров для объектов
 * без поддержки слабых ссылок

В версии [1.1](https://golang.org/doc/go1.1#performance) сборщик мусора стал почти точным (сборщик вс), что немного увеличило расходы на работу сборщика, но позволило сильно уменьшить размеры хипа. (почему?). Так же сборка стала более паралельной, что уменьшило паузы(latency) на системах с несколькими ядрами.

Следующие значительные изменения были в версии [1.3](https://golang.org/doc/go1.3#garbage_collector). Теперь сборка стала полностью точной, а этап освобождения памяти (sweep) стал конкурентным, что значительно уменьшило паузы.

Версия [1.4](https://golang.org/doc/go1.4#runtime) стала фундаментом для перехода на полностью конкурентный сборщик мусора. Рантайм языка был почти полностью переписан с C на Go. Что позволило сборщику быть абсолютно точным и знать о каждом указателе в программе. Теперь не было проблем с числами, похожими на указатели, которые висели в памяти. Это и другие улучшения позволили сильно уменьшить размеры хипа, до 10-30%. 

Для подготовки к конкурентному сборщику, теперь запись в указатель производится не напрямую, а через специальную функцию с барьером на запись (write-barrier). Это немного увеличило накладные расходы (блок про решение о переносе части прогиба в 1.4). Но в целом сборка стала быстрее. Перенос этой функциональности, позволил производительности Go расти от версии к версии.


### Глобальные изменения в Go 1.5

 * hybrid stop-the-world/concurrent collector
 * stop-the-world part limited by a 10ms deadline
 * CPU cores dedicated to running the concurrent collector
 * tri-color mark-and-sweep algorithm
 * fully precise
 * incurs a small cost if the program is moving pointers around
 * lower latency, but most likely also lower throughput, than Go 1.3 GC

Что сделано, что это значит? Вместо того, чтобы останавливать мир и делать всю работу. В новом сборщике, часть работы производится параллельно выполнению программы, соответственно пауза уменьшается, но общая работа сборщика увеличивается, то есть производительность программы снижается. При этом даются определенные гарантии, 25 процентов, 10/50. 

``` go
package main

import (
	"fmt"
)

func main() {
	fmt.Print("hello world")
}
```

Прежде чем углубиться в подробности, как это устроено под капотом, попробуем провести тесты, чтобы понять в чем различия. Вот код программы, которая активно использует сборщик. Запусти её в версиях 1.4 и 1.5 при разном количестве ядер. 

Видно как уменьшились паузы. Но для версии, использующей все мощности процессора видно небольшое падение производительности по времени.

Итак, давайте заберемся в эту нору и углубимся в мир рантайма го. Вот исходный код, в котром вы можете покопаться (в конце ссылки на обсуждения и пропозалы)
Картинка как происходит сборка с этапами.
Первый этап, сканирование корневых обьектов, активные локальные переменные. ( где они берутся, как получить их в го, связь с горутинами) Небольшая остановка мира. В коде идет переключение в фазу, установка барьеров(пояснить), ожидание горутин. 
Второй этап, конкуретная обработка и маркировка. Рассказать про процесс маркировки и цвета. 
Остановка мира, доделывание работы
Процесс очистки, как это происходит в го.
 
#### Рассказ про пейсинг. 

Теория и Проблемы пейсинга. Узнать как это сделано в джава.



### Что ожидает нас в будущих версиях?

В будущей версии планируется реализовать много всего. Желание добиться уменьшение пауз и прямой зависимости от размера хипа.
Ожидание фидбек сообщества и опыта работы с 1.5. Из возможных планируемых улучшений:  
Бамп поинтеры, что это? Позволит улучшить производительность.
Добавление поколений. Старое будет работать как щас, а новые будут ограничены по размеру и влезать при очистке в 10мс.
Принятое решение приоритета конкурентности в 1.5 перед производительностью в 1.6 позволит го стать более интересным для новых пользователей, которые раньше сомневались. Бла бла.


### Список литературы:



Одно из улучшений это предсказуемость пауз, за это бьется c4 в джава и азуль (узнать точно)
